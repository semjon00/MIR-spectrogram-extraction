#version 430
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

//_GEN_BUFFERS

// Saves sample activation value to Act
void to_output(int hair_i, float sample_i, float value) {
    float el_f = (len1(Act) * sample_i) / len(Samples);
    highp int el_w = int(el_f);
    float el_d = el_f - float(el_w);

    int y_index = len0(Act) - 1 - hair_i;
    Act[y_index][el_w] += (1 - el_d) * value;
    Act[y_index][el_w + 1] += el_d * value;
}

void main() {
    int hair_i = int(gl_WorkGroupID.x);

    // Bins that constitute one halfsine
    float _halfsine_span = 0.5 * float(FrameRate) / HairsFreq[hair_i];
    highp int _halfsine_span_w = int(_halfsine_span);
    float _halfsine_span_d = _halfsine_span - float(_halfsine_span_w);

    float hair_pos = 0.0;
    float hair_speed = 0.0;
    for (int op_i = 1; op_i < len(Samples); ++op_i) {
        hair_speed += - Pull[hair_i] * hair_pos; // Acc pull
        hair_speed += (Samples[op_i] - Samples[op_i - 1]); // Acc response
        hair_speed += - hair_speed * Friction[hair_i]; // Acc friction
        hair_pos += hair_speed;

        CycAgg[hair_i]<op_i> = CycAgg[hair_i]<op_i-1> + abs(hair_speed);

        float act = CycAgg[hair_i]<op_i>;
        act -= (1.0 - _halfsine_span_d) * CycAgg[hair_i]<op_i - _halfsine_span_w>;
        act -= (_halfsine_span_d) * CycAgg[hair_i]<op_i - _halfsine_span_w - 1>;
        act /= HairsFreq[hair_i];

        to_output(hair_i, op_i, act);
    }
}
