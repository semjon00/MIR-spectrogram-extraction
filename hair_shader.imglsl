#version 430
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

//_GEN_BUFFERS

#define M_PI 3.1415926535897932384626433832795

// Saves sample activation value to Act
void to_output(int hair_i, int sample_i, float value) {
    int y_index = len0(Ans) - 1 - hair_i; // We want lower frequences to be at the bottom of the image

    if (IS_LOSSLESS) {
        Ans[y_index][sample_i] = value;
    } else {
        float sample_i_f = float(sample_i);
        float el_f = (len1(Ans) * sample_i_f) / len(Samples);
        highp int el_w = int(el_f);
        float el_d = el_f - float(el_w);
        Ans[y_index][el_w] += (1 - el_d) * value;
        Ans[y_index][el_w + 1] += el_d * value;
    }
}

void main() {
    int hair_i = int(gl_GlobalInvocationID.x);
    if (hair_i >= len0(HairsFreq)) {
        return;
    }

    // Bins that constitute one halfsine
    float _sine_span = float(FrameRate) / HairsFreq[hair_i];
    highp int _sine_span_w = int(_sine_span);
    float _sine_span_d = _sine_span - float(_sine_span_w);

    // Read from the previous input chunk
    float hair_pos = HairsPos[hair_i];
    float hair_speed = HairsSpeed[hair_i];

    for (int op_i = ProcessingStart; op_i < ProcessingEnd; ++op_i) {
        // General pendulum physics (discrete, that is, imprecise)
        hair_speed += - Pull[hair_i] * hair_pos; // Acc pull
        hair_speed += (Samples[op_i] - Samples[op_i - 1]); // Acc response
        hair_speed += - hair_speed * Friction; // Acc friction
        hair_pos += hair_speed;

        // Perceived activation
        CycRawAcc[hair_i]<op_i> = abs(hair_speed);
        float old = _sine_span_d * CycRawAcc[hair_i]<op_i - _sine_span_w>;
        old += (1.0 - _sine_span_d) * CycRawAcc[hair_i]<op_i - _sine_span_w - 1>;
        float pacc = max(0.0, abs(hair_speed) - old * HalfsineNondecay[hair_i]);
        pacc *= HairsFreq[hair_i]; // Compensate for hair frequency
        pacc /= FrameRate; // FrameRate affects (A) _sine_span and (B) sum(abs(signal)) in second
        pacc /= TenfoldDecay; // Lower friction facilitates higher amplitude
        //CycAggPacc[hair_i]<op_i> = pacc;

        //float new = CycAcc [hair_i]<op_i>;
        //float old = _sine_span_d * CycAcc [hair_i]<op_i - _sine_span_w>;
        //old += (1.0 - _sine_span_d) * CycAcc [hair_i]<op_i - _sine_span_w - 1>;
        //float additional = max(0.0, new - old * SineNondecay [hair_i]);

        to_output(hair_i, op_i, pacc);
    }

    // Pass to the next input chunk
    HairsSpeed[hair_i] = hair_speed;
    HairsPos[hair_i] = hair_pos;
}
